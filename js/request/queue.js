// Generated by CoffeeScript 2.2.0
var Denque, RequestQueue, debug, extend, indexOf, set, uhoh, wait;

({extend, set, uhoh, wait} = require("../utils"));

Denque = require("denque");

debug = require("debug");

// TODO: Avoid resending insert, update, and replace requests.
RequestQueue = function(limit, box) {
  this.unsent = new Denque;
  this.limit = limit || null;
  this.sent = new Denque;
  set(this, "_box", box);
  set(this, "_paused", true);
  return this;
};

extend(RequestQueue, {
  // Add a request.
  push: function(req) {
    if (!(this._paused || this.sent.size() === this.limit)) {
      return this._send(req);
    }
    this.unsent.push(req);
  },
  // Fulfill or reject a pending request.
  resolve: function(id, ok, res) {
    var i, req;
    i = indexOf(id, this.sent);
    req = this.sent.removeOne(i);
    clearTimeout(req._timeout);
    if (ok) {
      req.resolve(req.transform(res[0x30]));
    } else {
      req.reject(Error(res[0x31]));
    }
    if (req = this._next()) {
      return this._send(req);
    }
  },
  // Pause flushing.
  pause: function() {
    this._paused = true;
  },
  // Resume flushing.
  resume: function() {
    var req;
    this._paused = false;
    while (req = this._next()) {
      this._send(req);
    }
  },
  // Move all sent requests to the front of the unsent queue.
  recover: function() {
    var count, i, req, sent, unsent;
    ({sent, unsent} = this);
    if (count = sent.size()) {
      i = -1;
      while (++i < len) {
        req = sent.peekAt(i);
        clearTimeout(req._timeout);
        if (req.retry !== false) {
          unsent.unshift(req);
        }
      }
      sent.clear();
    }
  },
  _next: function() {
    if (!(this._paused || this.sent.size() === this.limit)) {
      return this.unsent.shift();
    }
  },
  _send: function(req) {
    var conn, opts, query, timeout;
    ({query, timeout} = req);
    if (query) {
      opts = query._build();
      req.build(req.cmd || query.cmd, opts);
      req.query = null;
    }
    conn = this._box._conn;
    conn.write(req.buf);
    this.sent.push(req);
    if (timeout == null) {
      timeout = this._box._timeout;
    }
    if (timeout > 0) {
      clearTimeout(req._timeout);
      req._timeout = wait(timeout, () => {
        return req.reject(uhoh("Request timed out", "ETIMEDOUT"));
      });
    }
  }
});

module.exports = RequestQueue;

// Find the index of a request.
indexOf = function(id, queue) {
  var i, len, req;
  i = -1;
  len = queue.size();
  while (++i < len) {
    req = queue.peekAt(i);
    if (id === req.id) {
      return i;
    }
  }
  return -1;
};
