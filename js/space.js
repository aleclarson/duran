// Generated by CoffeeScript 2.2.0
var Range, Space, Tuple, alias, assertValid, extend, set, unimpl;

({alias, extend, set, unimpl} = require("./utils"));

assertValid = require("assertValid");

Range = require("./query/range");

Tuple = require("./query/tuple");

// TODO: Support custom field validation?
// TODO: Use the request queue for admin methods.
Space = function(name, box) {
  this.id = null;
  this.name = name;
  set(this, "_box", box);
  set(this, "_format", null);
  set(this, "_indexMap", null);
  set(this, "_fieldCount", null);
  return this;
};

extend(Space, {
  create: async function(opts = {}) {
    assertValid(opts, "object");
    this.id = (await this._box.call("duran.space_create", this.name, opts));
    this._indexMap = {};
    this._fieldCount = 0;
  },
  rename: async function(name) {
    assertValid(name, "string");
    if (this.id === null) {
      throw Error(`Unknown space: '${this.name}'`);
    }
    await this._box.call("duran.space_rename", this.id, name);
    this._box._schema.renameSpace(this.name, name);
    this.name = name;
  },
  format: function(format) {
    return this._box.call("duran.space_format", this.id, format);
  },
  truncate: function() {
    return this._box.call("duran.space_truncate", this.id);
  },
  drop: async function() {
    await this._box.call("duran.space_drop", this.id);
    return this._box._schema.deleteSpace(this.name);
  },
  
  // Indexes

  createIndex: async function(name, opts) {
    this._exists();
    if (this._indexMap[name]) {
      throw Error(`Index named '${this.name}.${name}' already exists`);
    }
    this._indexMap[name] = {
      id: (await this._box.call("duran.index_create", this.id, name, opts)),
      unique: opts.unique !== false
    };
  },
  renameIndex: async function(name, new_name) {
    var index;
    this._exists();
    index = this._getIndex(name);
    await this._box.call("duran.index_rename", this.id, name, new_name);
    this._indexMap[new_name] = index;
    return delete this._indexMap[name];
  },
  alterIndex: function(name, opts) {
    var index;
    this._exists();
    index = this._getIndex(name);
    return this._box.call("duran.index_alter", this.id, index.id);
  },
  dropIndex: async function(name) {
    var index;
    this._exists();
    index = this._getIndex(name);
    await this._box.call("duran.index_drop", this.id, index.id);
    return delete this._indexMap[name];
  },
  
  // Queries

  get: function(id) {
    var q;
    q = new Tuple(this);
    q.id = id;
    return q;
  },
  nth: unimpl("Space#nth"),
  find: unimpl("Space#find"),
  insert: unimpl("Space#insert"),
  update: unimpl("Space#update"),
  delete: unimpl("Space#delete"),
  asc: function(index) {
    var q;
    q = new Range(this);
    q.index = index || 0;
    q.iter = ip.EQ;
    return q;
  },
  desc: function(index) {
    var q;
    q = new Range(this);
    q.index = index || 0;
    q.iter = ip.REQ;
    return q;
  },
  where: unimpl("Space#where"),
  run: function() {
    return new Range(this).run();
  },
  then: function(resolveFn, rejectFn) {
    return new Range(this).then(resolveFn, rejectFn);
  },
  catch: function(rejectFn) {
    return new Range(this).catch(rejectFn);
  },
  
  // Internal

  _exists: function() {
    if (this.id === null) {
      this._box._schema.deleteSpace(this.name);
      throw Error(`Unknown space: '${this.name}'`);
    }
  },
  _getIndex: function(name) {
    var index;
    if (index = this._indexMap[name]) {
      return index;
    }
    throw Error(`Unknown index: '${this.name}.${name}'`);
  }
});


// Aliases

alias(Space, {
  empty: "truncate"
});

module.exports = Space;
